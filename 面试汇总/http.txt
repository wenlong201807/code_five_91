HTTP 0.9
只支持 GET, 响应只能返回 HTML 文本数据
每个请求单独创建 TCP 连接, 响应完 TCP 断开
// DEMO
GET /index.html
<html>...</html>

HTTP 1.0
增加 HTTP 头部字段, 能传输文字,图片,视频,二进制文件
增加响应状态码, POST, HEAD, 头部 - Content-Type 不只限于文本, Expires, Last-Modified, 
Authorization, Connection: keep-alive 长连接
通过 Content-Type 能传输任何格式的数据, 仍一个请求对应一个 TCP 连接
一个 HTTP 请求响应结束后才能发起下一个 HTTP 请求

HTTP 1.1
持久连接 - TCP 连接后不立即关闭, 多个 HTTP 请求可复用
管线化 - 多个 HTTP 请求可批量发, 按照发送的顺序返回响应, 如排序靠前的响应耗时会阻塞靠后的所有响应
响应分块 - 不用一次返回所有数据拆分成多个模块, 产生一块就发送一块, 减少响应延迟
          如 Transfer-Encoding 头
增加 Host 头 - 将一台服务器分成若干主机, 可在一台服务器部署多个网站
增加 Cache-Control, E-Tag 缓存头
增加 put, patch, head, options, delete 请求方法
每个域名至多打开6个连接, 

HTTP 2
基于二进制特性, 传输优化
将 HTTP 请求分3部分: 
帧 - 传输最小单位, 有唯一标识指向所在数据流
消息 - 请求或响应对应一个或多个帧
数据流 - 承载一条或多条消息的双向字节流
=> 不同数据流的帧可交错发送, 再根据帧头标识重新组装
请求优先级 - 多个请求同时发送, 产生多个数据流, 其中有优先级标识, 根据这个响应的优先顺序
多路复用 - 可交错发送, 根据帧首部标识符找到对应的流进而重新组合得到最终数据
服务器端推送 - 可主动向客户端发送资源并缓存到客户端避免二次请求
              HTTP 1.1 请求页面浏览器发一个 HTTP 请求得到相应并解析, 如有 <script src="..."></script>
              则再次发起请求获取 JS, HTTP 2 可返回 HTML 同时将用到的 CSS,JS 一起返回解析到标签不用请求
头部压缩 - HTTP 2 通信双方各自缓存一份头部字段表, 如 Content-Type: text/html 存入索引表
          后续如用则只发送对应索引号  必须使用 TLS 协议
=> HTTP 2 已优化到极致如需继续优化需先优化 TCP
TCP 存在头阻塞, 使用序列号标识数据顺序, 一旦某个数据丢失则后面的需等待这个数据重传后才能下一步处理
TCP 每一次建立需三次握手, 释放需四次挥手. 传输效率不稳定

HTTP 3 - 解决思路是替换掉 TCP. 还在草案阶段
使用 QUIC 替换 TCP, 没有连接概念不需三次握手, 可靠,安全,并发
连接更快 - 不需三次握手
多路复用 - 丢一个包不会影响后面的. 每个包可独立,交错发送,避免 TCP 头阻塞