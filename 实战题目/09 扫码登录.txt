二维码扫码登录是什么原理
二维码登录的本质
如账号密码登录, 账号是告诉系统我是谁, 面面是向系统证明我是谁. 同理手机号对应账号, 验证码对应密码
扫码过程没用输入密码也没有输入验证码, 是怎么证明的
手机端 APP 是已登录过的, 只要扫码确认是这个手机且是这个账号操作, 就能简介证明我是谁
一维码就是超市的条形码, 是一串数字上面存储了商品的序列号
二维码与条形码类似, 只是存储的不一定是数字还可是任何的字符串, 可理解是字符串的另一种表现形式
很多在线生成二维码的工具网站, 提供字符串与二维码之间相互转换功能

系统认证机制
为了安全手机端不会存储登录密码的, 应用下载下来第一次登录才需密码登录,
之后即使应用进程被杀或手机重启都不需再次输入账号密码就可自动登录
这背后是一套基于 token 的认证机制
账号密码登录返回 token 携带 token key 访问 API 校验 token 返回响应
1. 账号密码登录时, 客户端会将设备信息一起传递给服务器
2. 如通过服务器会把账号与设置进行一个绑定, 存在一个数据结构, 包含了账号ID,设备ID,设备类型等
const token = {
  acountid:'账号ID',
  deviceid:'登录的设备ID',
  deviceType:'设备类型，如 iso,android,pc......',
}
服务端生成一个 token 用来映射数据结构, 可找到对应的账号和设备信息
1. 客户端得到 token 本地保存每次访问 API 携带 token 与设备信息
2. 服务端通过 token 找到绑定的账号与设备信息, 把绑定的设备信息与客户端每次传来的设备信息比较
   相同则通过, 返回 API 响应数据. 不同则不通过拒绝访问
就算别人知道 token 也没影响, 因为设备信息是唯一的, 只要设备信息别人不知道其他设置访问验证是不通过的
可以说客户端登录的目的是获取属于自己的 token

扫码登录 PC 端怎么获取自己的 token 手机端 token 只能属于某个客户端私有其他人或客户端用不了的

扫描二维码登录的一般步骤
1. 扫码前手机端已登录状态, PC端显示二维码
2. 手机端扫描后, PC端提示"已扫描请在手机端点击确认"
3. 手机端点击确认后 PC端登录成功
=> 二维码有三个状态: 待扫描,已扫描待确认,已确认
1. 二维码一定存在一个唯一性 ID 二维码生成 ID 一起生成, 且绑定 PC 端的设备信息
2. 手机扫码
3. 二维码切换为已扫码待确认状态, 此时将账号信息与这个 ID 绑定
4. 手机端确认登录生成 PC 端用户登录 token 返回给 PC端

二维码准备
1. PC 端发送请求, 告知服务器要生成用户登录的二维码,并把 PC 端设备信息传递给服务器
2. 服务器收到请求生成二维码ID, 并将二维码ID与PC端设备信息绑定
3. 把二维码ID返回给PC端
4. PC端收到二维码ID生成二维码
5. 为了及时知道二维码状态, 客户端展示二维码后 PC 端不断轮询服务器如每隔一秒轮询一次
   请求服务端告知当前二维码的状态和相关信息

扫码状态切换
1. 手机扫码, 通过二维码内容获取 ID
2. 再调用服务器 API 将移动端的身份信息与二维码 ID 一起发给服务端
3. 服务端接收后将身份信息与二维码 ID 绑定生成临时 token 返回给手机端
4. PC端一直轮询二维码状态, 这时二维码状态变化可更新为已扫码
为什么返回给手机端一个临时 token 呢? 其与 token 一样也是身份凭证, 不同的是只能用一次用过就失效
返回的临时 token 为的是手机端在下一步操作用它作为凭证, 确保扫码登录两部操作是同一部手机发出的

状态确认
1. 手机端接收到临时 token 后弹出确认登录界面, 点击确认手机携带临时 token 调用服务端接口告知服务端已确认
2. 服务端收到确认后根据二维码 ID 绑定的设备信息与账号信息生成 PC 端登录 token
3. 此时 PC 端的轮询接口, 得知二维码状态已变成"已确认" 且从服务端获取到用户登录 token
4. 登录成功了 PC 端可用 token 访问服务端资源
