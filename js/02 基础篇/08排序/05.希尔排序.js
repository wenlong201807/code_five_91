// 参考学习 https://www.cnblogs.com/cc-freiheit/p/10983821.html

/*
希尔排序
　　1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。

 

算法描述：
　　将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：

选择一个增量序列t1，t2，…，tk，其中t1>t2>...，tk=1；
按增量序列个数k，对序列进行k 趟排序；
每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度

操作执行 举例数组 [8, 9, 1, 7, 2, 3, 5, 4, 6, 0]
1 初始增量 gap=length/2=5,意味着整个数组被分为5组。
分别为： [8, 3] [9, 5] [1, 4] [7, 6] [2, 0]
2 对这5组分别进行直接插入排序，结果如下
分别为： [3, 8] [5, 9] [1, 4] [6, 7] [0, 2]
经过这一轮插入排序操作，数组序列内容更新为 [3, 5, 1, 6, 0, 8, 9, 4, 7, 2]
3 重新变更增量值 gap = （上一轮的增量值）/ 2 = 2
即将更新后的数组切割为两组 [3, 1, 0, 9, 7] [5, 6, 8, 4, 2]
对切割出来的每一个数组进行插入排序重组 可得 [0, 1, 3, 7, 9] [2, 4, 5, 6, 8]
经过这一轮插入排序操作，数组序列内容更新为 [0, 2, 1, 4, 3, 5, 7, 6, 9, 8]
4 重复第3步操作，增量值减半（最后变为1时，即为希尔排序结果）
经过这一轮插入排序操作，数组序列内容更新为 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
*/

function shellSort(arr) {
  let len = arr.length;
  // gap 即为增量
  for (let gap = Math.floor(len / 2); gap > 0; gap = Math.floor(gap / 2)) {
    for (let i = gap; i < len; i++) {
      let j = i; // 额外增加一个遍历，控制索引
      let current = arr[i];
      while (j - gap >= 0 && current < arr[j - gap]) { // 分组的插入排序操作
        arr[j] = arr[j - gap];
        j = j - gap; // 当前值与已经排序的部分一个一个对比，如果当前值小于排序值，则将原来排序值移动到当前值位置
      }
      arr[j] = current; // 确定了当前值在原来排序位置的最后位置，放入对应位置
    }
  }
  console.info('arr:', arr);
  return arr;
}

var arr = [8, 9, 1, 7, 2, 3, 5, 4, 6, 0];
// var arr = [3, 5, 7, 1, 4, 56, 12, 78, 25, 0, 9, 8, 42, 37];
shellSort(arr);
