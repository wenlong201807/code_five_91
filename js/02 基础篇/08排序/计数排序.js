/*
桶排序，基数排序以及计数排序理论上复杂度都可以达到线性，这是这些算法相比上面提到的最大的优点。缺点就是空间复杂度可能比较高，对数据要求比较严格。

我们来看下计数排序的具体算法，你就明白为什么它最好可以达到线性时间，以及为什么有些情况空间复杂度会很高了。

仍然以数组 [0,4,8,5,7,1,3,9] 为例。

最大值是 9， 最小值是 0， 因此需要建立一个大小为 9 - 0 + 1 = 10 的数组，其中数组的索引表示的数字减去最小值的差（因此一定是非负数），值表示该数字出现的次数。

实际算法，很多时候不需要求最大值和最小值再计算数组大小，而是直接根据题目的数据范围确定数组大小。 比如题目说了数组每一项都在 [100, 10^5] 之间。那么就建立一个大小为 10 ^ 5 的数组即可

此时数组是 [0,0,0,0,0,0,0,0,0,0]。

依次将所有数组放到计数数组上，具体来说就是先找到他们的位置， 然后更新计数器，使其加 1。

[1,0,0,0,0,0,0,0,0,0] 先放 0

[1,0,0,0,1,0,0,0,0,0] 再放 4

[1,0,0,0,1,0,0,0,1,0] 再放 8

。。。

最后计数数组会变成：[1,1,0,1,1,1,0,1,1,1]。

接着我们遍历一次计数数组即可得到一个有序的数组。
*/

// counts = [1, 2, 0, 1, 1, 1, 0, 1, 1, 3];
counts = [1, 1, 0, 1, 1, 1, 0, 1, 1, 1];
nums = [0, 4, 8, 5, 7, 1, 3, 9];
lower = 0;
cur = 0;
for (let i = 0; i < counts.length; i++) {
  console.log(typeof i);
  let count = counts[i];
  // 数组可能有重复元素， 因此需要 while 循环一下
  while (count !== 0) {
    count -= 1;
    nums[cur++] = i + lower;
  }
}
console.log(nums); // [0, 1, 3, 4, 5, 7, 8, 9]
/*
不难看出计数排序的时间和空间复杂度实际取决于数字的分布情况，而不是数组的大小。

计数排序的空间复杂度是 O(upper - lower)O(upper−lower)，其中 upper 为 数组的最大值， lower 为数组的最小值。 可以看出，如果数组中的值比较集中，那么使用计数排序则非常高效，相反则会浪费大量空间。

值得注意的是，就稳定性而言上面的算法是不稳定的。

不过我们可以继续优化，使得他变得稳定，代价就是 O(N)O(N)的额外空间。

具体来说，我们可以：

使用一个额外数组， 这个数字是原数组的拷贝。

对所有的计数累加，从 counts 中的第一个元素开始，每一项和前一项相加。还是以上面的例子来说， 此时的 counts 为 [1,2,2,3,4,5,5,6,7,8]

反向填充目标数组，将每个元素 a 放在新数组的第 counts[a]项，每放一个元素就更新 counts, 即将 counts[i]减去 1。

代码：
*/

counts = [1, 2, 0, 1, 1, 1, 0, 1, 1, 3];
nums = [9, 1, 0, 9, 4, 8, 5, 7, 1, 3, 9];
copy = [];
lower = 0;

for (let i = 1; i < counts.length; i++) {
  counts[i] += counts[i - 1];
}

for (let i = nums.length - 1; i >= 0; i--) {
  const a = nums[i];
  copy[counts[a] - lower - 1] = a;
  counts[a] -= 1;
}
console.log(copy); // [0, 0, 1, 3, 4, 5, 7, 8, 9]
/*
由于 nums 是按照顺序遍历的， 因此最终排序的数组也会按照原来 nums 的顺序出现， 因此这种算法是稳定的。相应地空间复杂会增加 O(N)O(N)，因此总的空间复杂度会变成 O(N + upper - lower)O(N+upper−lower)。

虽然直接考计数排序的题很少见，但是计数排序的应用却很广泛， 笔者在很多题目都用到了它。只不过有的时候不需要你排序而已，另外状态压缩也会使用二进制位存储状态，区别于计数排序需要记录次数， 状态压缩往往关心的是否存在。

举一个例子，请听题。

题目描述：

题目是英文的， 为了不曲解题目意思， 我直接贴的原文。 题目大概意思是给你一个数组 array，要求你找出这个数组的最长连续数组。 注意这个数组的相对顺序不一定和 array 的顺序保持一致。 返回的时候也没必要把最长连续数组这个返回， 而是仅返回两个端点即可。 比如 [1, 11, 3, 0, 15, 5, 2, 4, 10, 7, 12, 6]，最长连续数组就是 [0,1,2,3,4,5,6,7]，尽管在原数组中他们不是这个顺序。由于值返回端点即可， 因此你需要返回 [0, 7]。

这道题并不需要对每一个数计数， 因为我们仅关心某一个数是否存在， 因此直接使用一个长度为 upper - lower 的数组记录每一个数的出现情况即可。 唯一需要注意的是负数的情况。

将数据离散化到 [0, upper - lower + 1]的数组上，索引为值，值为 1（二值化）。其中 upper 为 数组的最大值， lower 为数组的最小值。

滑动窗口思路计算最大的连续 1 即可。

代码：
*/

function largestRange(array) {
  upper, (lower = max(array)), min(array);
  temp = [0] * (upper - lower + 1);
  l = cnt = ans = 0;
  for (let i = 0; i < array.length; i++) {
    temp[array[i] - lower] = 1;
  }
  for (let i = 0; i < temp.length; i++) {
    cnt += temp[i];
    if (temp[i] == 0) {
      cnt = 0;
    }
    if (cnt > ans) {
      ans = cnt;
      l = i - cnt + 1;
    }
  }
  return [l + lower, l + ans + lower - 1];
}
/*
复杂度分析

时间复杂度：O(upper - lower)O(upper−lower)，其中 upper 为 数组的最大值， lower 为数组的最小值。

空间复杂度：O(upper - lower)O(upper−lower)，其中 upper 为 数组的最大值， lower 为数组的最小值。

类似的题目还有很多， 读者可以在平时的练习过程中多多感受一下。

总结
冒泡排序最差的情况以及平均情况都可以达到 O(n^2)O(n 
2
 )，而在最好的情况是数组已经有序， 我们可以提前退出， 此时时间复杂度可以达到 O(n)O(n)。而空间复杂度为 O(1)O(1)。又由于相同的数，并不会发生交换， 因此冒泡排序是一种稳定排序。

归并排序最好的情况，最差的情况以及平均情况都可以达到 O(nlogn))O(nlogn))。由于借助了中间数组，因此空间复杂度为 O(n)O(n)，此时递归产生的 O(logn)O(logn) 调用栈并不是算法的瓶颈。又由于相同的数合并的过程不会改变相对位置，因此归并排序也是一种稳定的排序算法。

快速排序最好的情况以及平均情况都可以达到 O(nlogn)O(nlogn)，而在最差的情况是 pivot 分布极度不均匀， 此时时间复杂度可以达到 O(n^2)O(n 
2
 )。而空间复杂度为递归栈的深度，因此为 O(logn)O(logn)。又由于相同的数，可能会发生交换， 因此快速排序是一种不稳定排序。 比如数组 [3, 4, 5, 5, 4, 3]，同时选择数组第一项为基准元素。v8 为了 排序稳定，在 es10 之后元素个数大于 10 都采用 timsort，在这之前使用的不稳定的快速排序算法。快速排序也是本章唯一的一种非稳定排序算法。

计数排序不管什么情况时间和空间复杂度都是 O(upper - lower + N)O(upper−lower+N)。又由于我们使用了额外的空数组，使得相同的数可以保持原有的顺序， 因此计数排序是一种稳定排序。

送给大家一张图， 方便大家记忆。


其中有几点需要大家注意：

符号 O(xxx) 表示最坏复杂度，而 Θ(xxx) 表示的平均复杂度。

快速排序是本章唯一一个不稳定的排序，因此在对复杂类型排序的时候需要考虑是否对稳定性有要求。

快速排序和归并排序的空间复杂度实际上可以进一步优化，感兴趣的可以查阅相关紫资料。

拓展 
堆专题 https://leetcode-solution.cn/solutionDetail?url=https%3A%2F%2Fapi.github.com%2Frepos%2Fazl397985856%2Fleetcode%2Fcontents%2Fthinkings%2Fheap.md&type=1
**/